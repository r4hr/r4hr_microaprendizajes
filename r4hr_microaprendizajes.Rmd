---
title: "Microaprendizajes de un Proyecto"
author: "Sergio Garcia Mora | Club de R para RRHH"
date: "22/05/2021"
output:
  html_document:
    theme: spacelab
    highlight: pygments
    toc: yes
    toc_float: yes
    code_download: yes
    code_fold: hide
---

# Introducci칩n

Esta presentaci칩n se centra en algunos *microaprendizajes* de un proyecto de an치lisis de resultados de una encuesta de diversidad e inclusi칩n.

Lo raz칩n por la que lo llamo *"microaprendizajes"* es porque no tuve que aprender muchas cosas desde cero, pero si aprend칤 varios truquitos que me sirvieron mucho.

Voy a usar una encuesta simulada para no violar la confidencialidad de los datos, pero va a ser algo an치logo a lo que estuve usando en el proyecto.

Para explotar al m치ximo esta sesi칩n conviene saber un poco de hacer informes con RMarkdown. Si necesit치s un tutorial sobre ese tema te comparto el [video que hicimos el a침o pasado](https://youtu.be/KT4UfTqAYoU).

### `r fontawesome::fa("github", fill = "steelblue")` [Repo](https://github.com/r4hr/r4hr_microaprendizajes)

Este material se puede utilizar y compartir sin fines comerciales y citando la fuente.

![Licencia](https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Cc-by-nc_icon.svg/1200px-Cc-by-nc_icon.svg.png){width="150"}

# Aprendizajes

## El *chunk* de 'setup'

El bloque de c칩digo de `setup` es muy 칰til para controlar c칩mo se van a comportar todos los bloques de c칩digo.

Mi archivo original tiene +150 bloques de c칩digo, imaginen si modificara uno por uno las caracter칤sticas de cada bloque.

```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.retina = 3,
                      out.width = "80%")
```

## Ordenar el c칩digo

Tener un orden en el c칩digo es muy importante para poder ir y venir r치pido y encontrar r치pidamente las cosas, modificar algo, y dem치s.

Dentro de los bloques de c칩digo tambi칠n es importante poner t칤tulos o marcadores que nos ayuden a encontrar r치pido las cosas. El orden que defin칤 fue:

1.  Librer칤as.
2.  Configuraciones generales
3.  Carga de datos
4.  Preprocesamiento y limpieza de datos
5.  Funciones

```{r inicio}
# Librer칤as -----
library(tidyverse)
library(gt)
library(scales)
library(extrafont)
library(readxl)


# Configuraciones generales ----------

# Colores
verde <- "#01B3B6"
negro <- "#333132"
gris <- "#AEB6BF"

color3 <- c(verde, gris, negro)
color2 <- c(verde, negro)

# Opciones de visualizaci칩n --------
options(scipen = 999)   # Modifica la visualizaci칩n de los ejes num칠rico a valores nominales

loadfonts(quiet = TRUE) # Permite cargar en R otros tipos de fuentes.

# Estilo limpio sin l칤neas de fondo
estilo <- theme(panel.grid = element_blank(),
                plot.background = element_rect(fill = "#FBFCFC"),
                panel.background = element_blank(),
                text = element_text(family = "Ubuntu Mono"))

# Estilo limpio con l칤neas de referencia verticales en gris claro
estilov <- theme(panel.grid = element_blank(),
                 plot.background = element_rect(fill = "#FBFCFC"),
                 panel.background = element_blank(),
                 panel.grid.major.x = element_line(color = "#ecf0f1"),
                 text = element_text(family = "Ubuntu Mono"))

# Estilo limpio con l칤neas de referencia horizontales en gris claro
estiloh <- theme(panel.grid = element_blank(),
                 plot.background = element_rect(fill = "#FBFCFC"),
                 panel.background = element_blank(),
                 panel.grid.major.y = element_line(color = "#ecf0f1"),
                 text = element_text(family = "Ubuntu Mono"))


# Creo un objeto con un texto que se va a repetir mucho a lo largo del an치lisis
fuente <- "Club de R para RRHH\nDatos Ficticios"

# Creo objetos para formatear las etiquetas num칠ricas de los ejes x e y
eje_x_per <- scale_x_continuous(labels = scales::percent_format(accuracy = 1))

eje_y_per <- scale_y_continuous(labels = scales::percent_format(accuracy = 1))

# Carga de Datos -----
encuesta <- read_excel("data/encuesta.xlsx")
plantel  <- read_excel("data/plantel.xlsx")

# Preparaci칩n de datos -----------

# Pivotea el dataset a un formato largo
enc <- encuesta %>% 
  pivot_longer(cols = c(7:11),
               names_to = "pregunta", 
               values_to = "valor")

# Cambia nombres y Organiza variables ordinales 

enc <- enc %>% 
  rename(id = "ID",
         genero = `쮺칩mo definir칤as tu identidad de g칠nero?`,
         unidad = "Unidad de Negocio",
         pais = "Pa칤s",
         sector = "Sector",
         cargo = "Tu cargo/nivel:") %>% 
  mutate(cargo = factor(cargo,
                        levels = c("Management", "L칤der", "Contribuidor individual")))

# Crea categor칤as de resultados

enc <- enc %>% 
  mutate(resultado = if_else(valor == "Totalmente de acuerdo", "Positivo", 
                             if_else(valor == "De acuerdo", "Positivo", 
                                     if_else(valor == "Ni de acuerdo ni en desacuerdo",
                                             "Neutral", "Negativo"
      )
    )
  ),
         resultado = factor(resultado, 
                            levels = c("Positivo", "Neutral", "Negativo")))

```

> Y comenten el c칩digo por amor a Jeb칰s!

![](files/comenten.png){width="300"}



## Poner el nombre a los bloques de c칩digo

Algo muy 칰til es ponerle nombre a los bloques de c칩digo. Por un lado porque es f치cil para navegar entre bloques busc치ndolos en RStudio.

Por ejemplo, probemos un gr치fico simple:

```{r grafico1}
ggplot(enc, aes(x = pais, fill = resultado)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = c(color3)) +
  estiloh +
  eje_y_per +
  labs(title = "Resultados por pa칤s",
       fill = "Resultado",
       x = "", y = "",
       caption = fuente)
```

Puede ocurrir que necesitemos reutilizar el gr치fico. Hacer la gran *stackoverflow* (copiar y pegar el c칩digo) es una opci칩n, pero puede generar errores y por otro lado implica tiempo de procesamiento.

En cambio, con la opci칩n `ref.label` podemos reutilizar lo que hicimos antes, de una forma m치s prolija y c칩moda pasando el nombre del bloque anterior.

Internamente, lo que hace R es reutilizar el c칩digo creado anteriormente.

```{r ejemplo1, eval=FALSE}
{r ref.label="grafico1"}
```

Voil치!

```{r ref.label="grafico1"}

```

## Etiquetas largas

A veces necesitamos presentar en un gr치fico o en una tabla la pregunta original de la encuesta. Por ejemplo, una de las "preguntas" de la encuesta dice:

> *`r enc[2,7]`*

Ahora veamos c칩mo se ven las preguntas en un gr치fico si intentamos hacer un ranking.

```{r etiq-largas}
enc %>% 
  group_by(pregunta, resultado) %>% 
  summarise(cant = n()) %>% 
  mutate(prop = cant/sum(cant)) %>% 
  filter(resultado == "Positivo") %>% 
  ggplot(aes(x = prop, y = pregunta)) +
  geom_col(fill = verde) +
  estilov +
  eje_x_per +
  labs(title = "Ranking de Respuestas Positivas",
       x = "", y = "",
       caption = fuente)
```

Queda hermoso, no? 游땸

Para sortear este problema podemos crear una columna nueva, y usar la funci칩n `str_wrap()` del paquete *stringr*.

Lo que hace esto es agregar el s칤mbolo `\n` que divide el texto en renglones. Con el par치metro `width` le indicamos la cantidad de caracteres de largo que tendr치 cada rengl칩n.

```{r etiq-largas1}
# Divide el largo de 'funci칩n' en varias l칤neas
enc$preg2 <- str_wrap(enc$pregunta, width = 40)

# Veamos como queda esto en el df
head(enc$preg2,5)

```

Y ahora podemos hacer un gr치fico que se vea bien:

```{r etiq-largas2}
enc %>% 
  group_by(preg2, resultado) %>% 
  summarise(cant = n()) %>% 
  mutate(prop = cant/sum(cant)) %>% 
  filter(resultado == "Positivo") %>% 
  ggplot(aes(x = prop, y = reorder(preg2, prop))) +
  geom_col(fill = verde) +
  estilov +
  eje_x_per +
  labs(title = "Ranking de Respuestas Positivas",
       x = "", y = "",
       caption = fuente)
```

Ahora queda mucho mejor `r emo::ji("+1")`

Tambi칠n se puede jugar con la altura del gr치fico usando la opci칩n `fig.height` en las opciones del bloque para que haya m치s espacio entre las barras.

```{r ej2, eval=FALSE}
{r fig.height=8} # El tama침o es exagerado en este caso
```

```{r etiq-largas3, fig.height=8}
ranking <- enc %>% 
  group_by(preg2, resultado) %>% 
  summarise(cant = n()) %>% 
  mutate(prop = cant/sum(cant)) %>% 
  filter(resultado == "Positivo") %>% 
  ggplot(aes(x = prop, y = reorder(preg2, prop))) +
  geom_col(fill = verde) +
  estilov +
  eje_x_per +
  labs(title = "Ranking de Respuestas Positivas",
       x = "", y = "",
       caption = fuente)

ranking
```

## Texto en los gr치ficos

Es simple agregar las etiquetas de datos a un gr치fico:

```{r texto1}
ranking +
  geom_text(aes(label = percent(prop, # Muestra los resultados como porcentaje
                                accuracy = 1)), # Indica la cantidad de decimales
            size = 3,                           # Cambia el tama침o de la letra
            hjust = 1.2,                        # Mueve la etiqueta para la izquierda
            family = "Ubuntu Mono") 
```

Miremos lo que pasa cuando queremos agregar m치s informaci칩n al gr치fico, por ejemplo, con los resultados por pa칤s.

```{r texto2}
ranking <- enc %>% 
  group_by(pais, preg2, resultado) %>% 
  summarise(cant = n()) %>% 
  mutate(prop = cant/sum(cant)) %>% 
  filter(resultado == "Positivo") %>% 
  ggplot(aes(x = prop, y = reorder(preg2, prop), fill = pais)) +
  geom_col(position = "dodge") +
  estilov +
  eje_x_per +
  labs(title = "Ranking de Respuestas Positivas",
       x = "", y = "",
       fill = "Pa칤s",
       caption = fuente) +
  scale_fill_brewer(palette = 2)

ranking +
   geom_text(aes(label = percent(prop, # Muestra los resultados como porcentaje
                                accuracy = 1)), # Indica la cantidad de decimales
            size = 3,                           # Cambia el tama침o de la letra
            hjust = 1.2,                        # Mueve la etiqueta para la izquierda
            family = "Ubuntu Mono")             # Modifica la fuente
```

El problema es que todas las etiquetas de cada barra est치n centradas con la etiqueta del eje *y*. En la gu칤a de `geom_text` en la documentaci칩n de `ggplot2` [encontramos como solucionar el problema](https://ggplot2.tidyverse.org/reference/geom_text.html) usando el par치metro `position_dodge()`.

```{r text3}
ranking <- ranking +
   geom_text(aes(label = percent(prop, # Muestra los resultados como porcentaje
                                accuracy = 1)), # Indica la cantidad de decimales
            position = position_dodge(0.9),     # Acomoda cada etiqueta con las barras
            size = 3,                           # Cambia el tama침o de la letra
            hjust = 1.2,                        # Mueve la etiqueta para la izquierda
            family = "Ubuntu Mono")             # Modifica la fuente

ranking
```

Otra mejora que podemos hacer al gr치fico es acomodar los colores en la leyenda (la referencia de los colores) para que tengan la misma secuencia que tiene en el gr치fico, es decir que el verde oscuro aparezca primero al igual que la barra con el verde m치s oscuro en el gr치fico.

En [esta p치gina](https://www.datanovia.com/en/blog/ggplot-legend-title-position-and-labels/) hay muchas variantes para trabajar con las etiquetas y leyendas.

```{r texto4}
ranking +
  guides(fill = guide_legend(reverse=TRUE)) + # Invierte el orden de los colores en la leyenda
  theme(axis.text.x = element_blank())
```

Cuando estamos mapeando una variable categ칩rica en el eje *y*, R lo ordena alfab칠ticamente desde *abajo* **hacia** *arriba*.

```{r textoy}
enc %>% 
  group_by(sector, resultado) %>% 
  summarise(cant = n()) %>% 
  mutate(prop = cant/sum(cant)) %>% 
  filter(resultado == "Positivo") %>% 
  ggplot(aes(x = prop, y = sector)) +
  geom_col(fill = verde) +
  estilov +
  eje_x_per +
  labs(title = "Resultado Positivos por Sector",
       x = "", y = "",
       caption = fuente)
```

Podemos usar la funci칩n `fct_rev` del paquete *forcats* para poner al rev칠s las etiquetas del eje *y* cuando estamos mapeando las variables dentro de `ggplot`

```{r textoy2}
enc %>% 
  group_by(sector, resultado) %>% 
  summarise(cant = n()) %>% 
  mutate(prop = cant/sum(cant)) %>% 
  filter(resultado == "Positivo") %>% 
  ggplot(aes(x = prop, y = fct_rev(sector))) + # Invertimos el orden del eje y
  geom_col(fill = verde) +
  estilov +
  eje_x_per +
  labs(title = "Resultado Positivos por Sector",
       x = "", y = "",
       caption = fuente)
```

## Funciones

Esto es un *work-in-progress* y tengo que agradecer a [M칩nica Alonso](https://twitter.com/MonicaLA2000) de RLadies Buenos Aires por la ayuda.

El problema es que me encontr칠 muchas veces escribiendo esta secuencia de c칩digo muchas veces:

```{r fun1}
# Calcular pocertajes de respuestas
enc %>% 
  group_by(genero, resultado) %>% 
  summarise(cant = n()) %>% 
  mutate(prop = cant / sum(cant))
```

Muchas veces resolv칤 copiando y pegando el c칩digo, pero se hace tedioso controlar cada uno de los bloques de c칩digo y gr치ficos. As칤 que para eso, podemos crear nuestras propias funciones.

```{r fun2}
cant_prop_gen <- function(df){
  df %>% 
    group_by(genero,resultado) %>% 
    summarise(cant = n()) %>% 
    mutate(prop = cant / sum(cant)) 
}
```

Y ahora lo podemos incorporar en nuestro flujo de trabajo como cualquier funci칩n.

```{r fun3}
enc %>% 
  cant_prop_gen() %>% 
  ggplot(aes(x = genero, y = prop, fill = resultado)) +
  geom_col(position = "dodge") +
  eje_y_per +
  estiloh +
  scale_fill_manual(values = color3) +
  labs(title = "Resultados por G칠nero",
       x = "", y = "",
       fill = "Resultado",
       caption = fuente)
```

Todav칤a estoy resolviendo como crear funciones usando cualquier tipo de variable en la funci칩n. Por ahora, lo estoy resolviendo creando una funci칩n para cada combinaci칩n de variables que agrupo. No es lo ideal, pero es lo que hay. 游뱡

Capaz encuentre lo que necesito en estos libros:

-   [R para Ciencia de Datos](https://es.r4ds.hadley.nz/)
-   [Hands-On Programming with R](https://rstudio-education.github.io/hopr/)
-   [Advanced R](https://adv-r.hadley.nz/index.html)

Ya les contar칠... stay tuned 游닠

## C칩digo Inline

Como sabemos, algo interesante de RMarkdown es la posibilidad de utilizar el c칩digo de los bloques dentro del texto.

As칤 que creemos un peque침o objeto primero para almacenar los resultados positivos y negativos por g칠nero.

```{r cod-inl}
result_genero <- enc %>% 
  cant_prop_gen()

result_genero
```

Usando la llamada de datos de un dataframe con `nombre_df[fila,columna]` puedo usar los resultados almacenados para incluirlos dentro del texto por ejemplo para decir:

*Los resultados positivos para las personas de g칠nero femenino es `r result_genero[1,4]`*.

Lo ideal es poder ver ese resultado como un porcentaje, as칤 que intuitivamente podemos usar la funci칩n `percent` para lograr eso...

...y no va a funcionar. Obtenemos el siguiente mensaje de error:

```{r eval=FALSE}
# Intento de c칩digo inline
`r percent(result_genero[1,4])`

# Quitting from lines 425-441 (r4hr_microaprendizajes.Rmd) 
# Error in is.finite(x) : default method not implemented for type 'list'
```

Para que la funci칩n `percent` funcione la tenemos que combinar con la funci칩n `pull` . Y ahora as칤 s칤 funciona:

*Los resultados positivos para las personas de g칠nero femenino es `r percent(pull(result_genero[1,4]))`* .

## *Trust the Tidyverse*

> *Lo barato sale caro*
>
> Dicho popular

![](https://linternasybosques.files.wordpress.com/2018/10/meme-no-creas.png){width="300"}

La encuesta que est치bamos analizando era an칩nima, lo cual hac칤a imposible poder cruzar datos contra el listado de empleados.

Pero, s칤 pod칤amos calcular los resultados seg칰n la composici칩n del liderazgo. Para eso ten칤amos que calcular el porcentaje de l칤deres hombres y mujeres por sector.

```{r trust1}

# Cuento la cantidad de l칤deres por sector y g칠enero
plantel <- plantel %>% 
  rename(division = `Unidad de Negocio`, 
         lider = L칤der, 
         sexo = G칠nero, 
         sector = Sector, 
         pais = Pa칤s) %>% 
  filter(lider == "true") %>% 
  group_by(pais, division, sector, lider, sexo) %>% 
  tally() %>% 
  ungroup()

plantel

```

```{r trust2}
# Pivoteo el dataset a un dataset ancho
plantel <- plantel %>% 
  pivot_wider(.,
              names_from = sexo,
              values_from = n)

# Reemplaza los NA con un 0
plantel[is.na(plantel)] <- 0


# Calculo porcentaje de l칤deres hombres
plantel %>% 
  mutate(prop_lider_hombre = if_else(Femenino == 0, 1, Masculino / (Masculino +Femenino))) %>% 
  select(-lider)

```
